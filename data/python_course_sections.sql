-- MySQL dump 10.13  Distrib 8.0.34, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: python_course
-- ------------------------------------------------------
-- Server version	8.0.35

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `sections`
--

DROP TABLE IF EXISTS `sections`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `sections` (
  `ID` int NOT NULL AUTO_INCREMENT,
  `ChapterID` int NOT NULL,
  `Title` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `TextContent` text NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `ChapterID` (`ChapterID`),
  CONSTRAINT `sections_ibfk_1` FOREIGN KEY (`ChapterID`) REFERENCES `chapter` (`ID`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sections`
--

LOCK TABLES `sections` WRITE;
/*!40000 ALTER TABLE `sections` DISABLE KEYS */;
INSERT INTO `sections` VALUES (1,1,'Section 1 - Introduction','Welcome to the Python Programming course! This course is designed for both beginners and those looking to enhance their existing Python skills. Python is a versatile and powerful programming language that is widely used in various industries, from web development to data science. By taking this course, you will gain a solid foundation in Python, learn to write efficient code, and solve real-world problems. Additionally, the interactive quizzes and practical exercises will help you sharpen your skills and reinforce your learning.Enter this exciting journey and become proficient in Python programming!'),(2,1,'Section 2 - Installing Python','To install Python, first visit the official Python website at python.org. Click on the \"Downloads\" tab and choose the appropriate version for your operating system (Windows, macOS, or Linux). For Windows, download the installer and run it, ensuring you check the box to add Python to your PATH. On macOS, download the installer and follow the prompts. For Linux, use your package manager (e.g., sudo apt-get install python3 for Ubuntu). Once installed, verify the installation by opening your command line interface and typing python --version. This should display the installed version of Python, confirming a successful installation.'),(3,1,'Section 3 - Setting up Visual Studio Code','To run Python programs, we will use Visual Studio Code (VS Code). First, download and install VS Code from code.visualstudio.com. Open the installer and follow the setup instructions. Once installed, open VS Code and go to the Extensions view by clicking on the square icon in the sidebar or pressing Ctrl+Shift+X. Search for \"Python\" and install the Microsoft Python extension. Next, open a terminal in VS Code (Ctrl+``) and verify Python is installed by typing python --version. Now you can create a new Python file (.py), write your code, and run it directly within VS Code by pressing F5`.'),(4,2,'Section 1 - Variables','In Python, variables are used to store data that can be referenced and manipulated within a program. A variable is essentially a name assigned to a value, allowing you to use that name to access the value later. You dont need to declare variables explicitly, as Python is dynamically typed. This means you can assign a value to a variable using the equals sign (=), like x = 10. Variable names should be meaningful and follow naming conventions, starting with a letter or underscore and not containing spaces. Python supports various data types for variables, such as integers, floats, strings, and lists, making it versatile for different kinds of data storage.'),(5,2,'Section 2 - Conditional Statements','In Python, conditional statements allow you to execute certain code blocks based on specific conditions. The if statement checks a condition, and if it evaluates to True, the code block within the if statement is executed. If the condition is False, the else block is executed if it is present. The elif (short for else if) statement allows you to check multiple conditions.Hereâ€™s an example: \nx = 10 \nif x > 0: \n    print(\"x is positive\") \nelif x == 0: \n    print(\"x is zero\") \nelse: \n    print(\"x is negative\") \n.In this example, since x is 10, the condition x > 0 evaluates to True, and \"x is positive\" is printed. If x were 0, the elif condition x == 0 would be True, and \"x is zero\" would be printed. If x were negative, the else block would execute, printing \"x is negative.\" Conditional statements are fundamental for controlling the flow of a program based on different conditions.'),(6,2,'Section 3 - Lists','In Python, lists are versatile data structures used to store collections of items. Lists can hold elements of different data types, including numbers, strings, and other lists. They are defined using square brackets, with elements separated by commas, like this: my_list = [1, \"hello\", 3.14, True] .Lists are ordered, mutable (changeable), and allow duplicate elements. You can access elements by their index, starting from 0, and modify them directly. Lists also come with various built-in methods, such as append(), remove(), and sort(), which make them powerful for managing collections of data efficiently.\n'),(7,2,'Section 4 - Loops','In Python, loops are used to repeatedly execute a block of code. The for loop can iterate over elements of a list. For example: fruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits:\n    print(fruit).This prints each fruit in the list. The for loop can also iterate over a range of numbers, which is useful for repeating an action a specific number of times. For example: for i in range(5):\n    print(i).This prints numbers from 0 to 4.The while loop runs as long as a condition is True. For example: count = 0\nwhile count < 5:\n    print(count)\n    count += 1.This prints numbers from 0 to 4.An infinite loop occurs when the loops condition always remains True. For example:while True:\n    print(\"Infinite loop\").This loop will run forever unless interrupted. To avoid infinite loops, ensure that loop conditions eventually become False.'),(8,3,'Section 1 - Declaration of a function ','In Python, functions are reusable blocks of code that perform a specific task. They are defined using the def keyword, followed by the function name and parentheses. Functions can accept parameters and return values. For example: def greet(name):\n    return f\"Hello, {name}!\" .In this example, the f before the string indicates an f-string, or formatted string literal. F-strings allow you to embed expressions inside string literals, using curly braces {}. This makes it easy to include variables and expressions directly within a string. Functions help organize code, make it more readable, and reduce redundancy. They can be built-in, like print(), or user-defined, allowing for customized behavior and modular programming.'),(9,3,'Section 2 - Return Statement','In Python, the return statement is used inside a function to send a value back to the caller. When a return statement is executed, the function terminates, and the specified value is returned. If no value is specified, None is returned by default. For example: def add(a, b):\n    return a + b . Here, add(2, 3) returns 5. The return statement allows functions to produce output that can be stored in variables, used in expressions, or passed to other functions, making it essential for modular and reusable code.'),(10,3,'Section 3 - Recursion','In Python, recursion is a programming technique where a function calls itself to solve a smaller instance of the same problem. It consists of two main parts: a base case, which terminates the recursion, and a recursive case, which continues the recursion. For example, calculating the factorial of a number: def factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1) .Here, factorial(5) calls itself with decreasing values until it reaches the base case. Recursion simplifies problems that can be divided into similar subproblems, though it requires careful design to avoid infinite loops and stack overflow.'),(11,4,'Section 1 - Strings Basics','In Python, strings are sequences of characters enclosed in single quotes (\'), double quotes (\"), or triple quotes (\'\'\' or \"\"\"). They are used to represent text. Strings are immutable, meaning their content cannot be changed after creation. Basic operations include concatenation (+), repetition (*), and slicing ([start:end]). Common methods include upper(), lower(), strip(), and replace(). You can also use formatted strings (f-strings) to embed expressions within string literals, like this: name = \"Alice\" greeting = f\"Hello, {name}!\" .Strings support iteration, indexing, and various built-in functions, making them versatile for text manipulation.'),(12,4,'Section 2 - Indexing','Indexing in Python allows you to access individual characters in a string using their position. Indices start at 0 for the first character and go up to len(string) - 1 for the last character. Negative indices can be used to count from the end of the string, with -1 being the last character. For example: s = \"Python\"\nprint(s[0])   # Outputs: P\nprint(s[-1])  # Outputs: n . Attempting to access an index outside the valid range raises an IndexError. Indexing provides a simple way to retrieve and manipulate specific characters within a string.'),(13,4,'Section 3 - Slicing','String slicing in Python allows you to extract a substring from a string using a specific range of indices. The syntax is string[start:stop:step], where start is the beginning index, stop is the ending index (not included), and step is the interval. For example: s = \"Hello, World!\"\nprint(s[0:5])  # Outputs: Hello\nprint(s[7:12]) # Outputs: World\nprint(s[::2])  # Outputs: Hlo ol! .Omitting start defaults to 0, omitting stop defaults to the strings length, and omitting step defaults to 1. Slicing provides a powerful way to manipulate and access specific parts of strings.'),(14,5,'Section 1 - Tuples','Tuples in Python are immutable, ordered collections of elements, defined by parentheses () and separated by commas. They can store elements of different data types, like integers, strings, and even other tuples. Once created, the elements of a tuple cannot be changed, added, or removed. This immutability makes tuples useful for storing fixed collections of data. You can access elements using indexing and perform operations like slicing, similar to lists. For example: my_tuple = (1, \"apple\", 3.14)\nprint(my_tuple[1])  # Outputs: apple .Tuples provide efficient, read-only access to collections of data.'),(15,5,'Section 2 - Dictionaries','Dictionaries in Python are versatile collections of key-value pairs, enabling efficient data retrieval based on unique keys. They are created using curly braces {} or the dict() function. Keys in dictionaries must be unique and immutable, while values can be of any data type. Here are some key functionalities. Accessing Values: Use square brackets [] to access values by their keys. my_dict = {\"name\": \"Alice\", \"age\": 25} print(my_dict[\"name\"])  # Outputs: Alice. Use the get() method to safely access values, providing a default if the key doesn\'t exist. print(my_dict.get(\"city\", \"Unknown\"))  # Outputs: Unknown. Assign values to keys to add or update items. my_dict[\"city\"] = \"New York\" my_dict[\"age\"] = 26. Removing Items: Use the pop() method to remove items by key and return the value. age = my_dict.pop(\"age\")  # Removes and returns 26. Use the del statement to remove items. del my_dict[\"city\"]. Methods: keys(), values(), items()... keys(): Returns a view object containing all the keys in the dictionary. keys = my_dict.keys() print(keys)  # Outputs: dict_keys([\'name\'])... values(): Returns a view object containing all the values in the dictionary. values = my_dict.values() print(values)  # Outputs: dict_values([\'Alice\'])... items(): Returns a view object containing all key-value pairs as tuples. items = my_dict.items() print(items)  # Outputs: dict_items([(\'name\', \'Alice\')])... These methods provide efficient ways to access the structure and contents of a dictionary, enabling iteration and manipulation of keys, values, and key-value pairs. By understanding and utilizing these functionalities, you can effectively manage and manipulate complex data structures in Python.'),(16,6,'Section 1 - Special Content','Variable Declaration: In Python, variables do not require explicit declaration. You assign values directly. For example, age = 25 is correct. Other forms like int age = 25 or age := 25 are incorrect in Python.\n\nChanging Variable Values: Use the assignment operator = to change the value of a variable. For example, x = 10 is the correct syntax. Other forms like x := 10 or int x = 10 are incorrect.\n\nConditional Statements: Use the if statement followed by a colon and an indented block. For example, if x > 0: print(\"x is positive\"). Syntax like if (x > 0) print(\"x is positive\") is incorrect.\n\nelif vs else: elif checks an additional condition if the previous conditions were false. else runs if no previous conditions were true. elif provides another condition to check, while else does not.\n\nLooping Through Lists: Use the for loop to iterate over elements. For example, for fruit in fruits: print(fruit) is correct. Other forms like for (fruit: fruits) are incorrect.\n\nfor vs while Loops: for loops iterate over a sequence, while while loops run until a condition is met. Use for for a known sequence and while for conditions.\n\nString Indexing: Use square brackets with the index to access characters in a string. For example, s[0] is correct. Other forms like s(0) are incorrect.\n\nString Slicing: Use the colon syntax within square brackets to slice strings. For example, s[7:12] extracts \"World\". Other forms like s(7, 12) are incorrect.\n\nAdding to Dictionaries: Use square brackets to add new keys and assign values. For example, my_dict[\"age\"] = 25 is correct.\n\nUsing get() Method in Dictionaries: get() retrieves a value for a key, providing a default if the key is not found. For example, my_dict.get(\"name\", \"Unknown\") safely retrieves the value.\n\nString Step Slicing: Step slicing skips elements in the sequence. For example, s[::2] skips every other character, producing Pto rgamn from Python Programming.\n\nReversing Strings: Use slicing with a step of -1. For example, s[::-1] correctly reverses the string Hello, World!.\n\nDefining Functions: Use the def keyword followed by the function name and parentheses. For example, def function_name(): is correct.\n\nFunction Default Parameters: Default parameters are used if no argument is provided. For example, Hello, World! and Hello, Alice! are printed by def greet(name=\"World\"): print(f\"Hello, {name}!\") greet() greet(\"Alice\").\n\nRecursive Functions: Recursion is a technique where a function calls itself to solve a problem. Each recursive call works on a smaller instance of the problem. Understand how recursive functions work by tracing each step. For example, given the function def factorial(n): if n == 1: return 1 else: return n * factorial(n - 1), calling factorial(5) results in the following steps: factorial(5) calls factorial(4), factorial(4) calls factorial(3), and so on until factorial(1), which returns 1. Then, the results are multiplied back up the call stack: 1 * 2 * 3 * 4 * 5, yielding 120.\n\nChecking Key Existence in Dictionaries: Use the in keyword to check for keys. For example, \'key\' in my_dict correctly checks for the key.\n\nDictionary Value Update: Use get() to safely access and update values. For example, 3 is the output after updating the value using my_dict = {\"a\": 1, \"b\": 2, \"c\": 3} my_dict[\"b\"] = my_dict.get(\"b\", 0) + 1 print(my_dict[\"b\"]).\n\nTuple Slicing: Use slicing to extract parts of a tuple. For example, (2, 3) is the correct output of my_tuple = (1, 2, 3, 4) print(my_tuple[1:3]).\n\nTuple Immutability: Tuples are immutable. For example, No, tuples are immutable. is the correct answer.\n\n');
/*!40000 ALTER TABLE `sections` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-09-22 18:47:26
